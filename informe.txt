Pablo Hernández Martínez - pablo.hernandez.martinez@udc.es 
Iván Moure Pérez - i.moure@udc.es


-----Informe Práctica 4 Algoritmos-----
Esta práctica consiste en implementar el algoritmo de Dijkstra mediante el
pseudocódigo que nos ha sido dado, validar que la implementación funcione 
correctamente (usando los datos que se proporcionan en las figuras 1 y 2), y por
último calcular empíricamente la complejidad computacional del algoritmo para el 
cálculo de las distancias mínimas (para grafos completos no dirigidos, con pesos
entre 1 y 1000)

-----Especificaciones de la máquina-----
Procesador: Intel® Core™ i7-1195G7 2.9GHz 
Memoria RAM: 16GB 
Sistema operativo: Windows 11 Home 64 bits 
Versión de Python: 3.10.5 64-bit


-----Ejercicio 1-----
El ejercicio 1 se trataba de implementar en PYTHON el algoritmo de Dijkstra
utilizando como base el pseudocódigo proporcionado.

///// Ejercicio 1
En este ejercicio tan solo implementamos las funciones matrizAleatoria() y
dijkstra() en el código de Python.

-----Ejercicio 2-----
El ejercicio 2 trata de validar que la implementación funcionase correctamente.
Utilizando los datos que se mostraban en las figuras 1 y 2 se del enunciado.

///// Ejercicio 2
+------------------------------------------------------------+
|                       Primer ejemplo                       |
+-----------------+--------------+--------------+------------+
| Matriz original |   Solución   |  Resultado   | ¿Funciona? |
+-----------------+--------------+--------------+------------+
|    [0 1 8 4 7]  |  [0 1 3 4 6] |  [0 1 3 4 6] |     ✓      |
|    [1 0 2 6 5]  |  [1 0 2 5 5] |  [1 0 2 5 5] |            |
|    [8 2 0 9 5]  |  [3 2 0 7 5] |  [3 2 0 7 5] |            |
|    [4 6 9 0 3]  |  [4 5 7 0 3] |  [4 5 7 0 3] |            |
|    [7 5 5 3 0]  |  [6 5 5 3 0] |  [6 5 5 3 0] |            |
+-----------------+--------------+--------------+------------+
+--------------------------------------------------------+
|                    Segundo ejemplo                     |
+-----------------+------------+------------+------------+
| Matriz original |  Solución  | Resultado  | ¿Funciona? |
+-----------------+------------+------------+------------+
|     [0 1 4 7]   |  [0 1 3 6] |  [0 1 3 6] |     ✓      |
|     [1 0 2 8]   |  [1 0 2 5] |  [1 0 2 5] |            |
|     [4 2 0 3]   |  [3 2 0 3] |  [3 2 0 3] |            |
|     [7 8 3 0]   |  [6 5 3 0] |  [6 5 3 0] |            |
+-----------------+------------+------------+------------+

-----Ejercicio 3-----
El ejercicio 3 trataba de calcular empíricamente la complejidad computacional
del algoritmo para el cálculo de las distancias mínimas. Generar los grafos
completos no dirigidos con pesos aleatorios entre 1 y 1000; con la posibilidad 
de usar uno de los dos códigos propuestos en la figura 3.

En este caso, hemos utilizado n**2.75 como cota subestimada, n**3 como cota 
ajustada y n**3.25 como cota sobreestimada.

Podemos deducir que en la tabla, la cota ajustada tiende a la constante
400.

///// Ejercicio 3
+---------------------------------------------------------------+
|        Matrices de adyacencia aleatorias con n vértices       |
+------+--------------+--------------+-----------+--------------+
|    n |     t(n)(ns) | t(n)/n**2.75 | t(n)/n**3 | t(n)/n**3.25 |
+------+--------------+--------------+-----------+--------------+
|  128 |    866411900 |      1389.62 |    413.14 |       122.83 |
|  256 |   6455077500 |      1539.01 |    384.75 |        96.19 |
|  512 |  53746833600 |      1904.85 |    400.45 |        84.18 |
| 1024 | 426258819100 |      2245.68 |    396.98 |        70.18 |
+------+--------------+--------------+-----------+--------------+
Tiempo total de ejecución del ejercicio 3: 487.34 segundos.


-----Tiempos medidos en bucles-----
En el caso de haber obtenido valores temporales que no hubiesen cumplido con el
umbral de confianza, habríamos iterado 100 veces el cálculo para recibir un 
resultado más preciso. En este caso, no hemos obtenido valores por debajo del
umbral.


-----Mediciones anómalas-----
No hemos obtenido valores temporales que se desvíen de los demás, probablemente
debido a las pocas iteraciones que realizamos (debido al tiempo de ejecución)

-----Conclusiones-----






